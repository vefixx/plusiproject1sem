АЛГОРИТМ РЕШЕНИЯ

1. ОБЩАЯ СТРУКТУРА ПРОГРАММЫ

Программа реализует простейшую систему управления базой данных (мини-СУБД) для работы с записями о пользователях. Данные хранятся в памяти в виде динамического массива (vector) структур User, каждая из которых содержит поля: имя (name), возраст (age), зарплата (salary) и уникальный идентификатор (id).


2. СТРУКТУРА ДАННЫХ

- Структура User:
  * name (string) - имя пользователя (до 30 символов)
  * age (short) - возраст (от 0 до 100)
  * salary (int) - зарплата (неотрицательное число)
  * id (int) - уникальный идентификатор записи

- Контейнер данных: vector<User> users - динамический массив для хранения всех записей в оперативной памяти


3. ОСНОВНОЙ АЛГОРИТМ РАБОТЫ ПРОГРАММЫ

Шаг 1: Инициализация
  - Установка кодировки консоли для корректного отображения русских символов
  - Создание пустого контейнера users для хранения записей
  - Переход к главному циклу программы

Шаг 2: Главный цикл программы (пока пользователь не выберет выход)
  2.1. Отображение главного меню с доступными операциями:
       - Загрузка из файла
       - Сохранение в файл
       - Вывод всех записей
       - Добавление пользователя
       - Удаление пользователя по ID
       - Поиск по полю
  
  2.2. Ввод выбора пользователя с валидацией:
       - Проверка корректности ввода (целое число)
       - Обработка ошибок ввода
  
  2.3. Выполнение выбранной операции через функцию HandleChoice()
  
  2.4. Возврат к шагу 2.1


4. АЛГОРИТМЫ ОТДЕЛЬНЫХ ОПЕРАЦИЙ

4.1. ЗАГРУЗКА ИЗ ФАЙЛА

Алгоритм LoadFromFile():
  1. Открытие файла с указанным именем для чтения
  2. Если файл не открыт - возврат false
  3. Очистка текущего контейнера users
  4. Чтение файла построчно:
     Для каждой строки:
     4.1. Парсинг строки формата "<имя>, <возраст>, <зарплата>"
     4.2. Валидация данных:
          - Имя: не пустое, длина <= 30 символов
          - Возраст: число от 0 до 100
          - Зарплата: неотрицательное число
     4.3. Если данные валидны:
          - Создание объекта User
          - Присвоение ID (инкремент от последнего ID или 0)
          - Добавление в контейнер users
  5. Закрытие файла
  6. Возврат true при успешной загрузке


4.2. СОХРАНЕНИЕ В ФАЙЛ

Алгоритм HandleSaveToFile():
  1. Ввод имени файла от пользователя
  2. Открытие файла для записи
  3. Если файл не открыт - вывод сообщения об ошибке и выход
  4. Для каждой записи в users:
     - Запись строки в формате: "<имя>, <возраст>, <зарплата>\n"
  5. Закрытие файла
  6. Вывод сообщения об успешном сохранении


4.3. ВЫВОД ВСЕХ ЗАПИСЕЙ

Алгоритм PrintTable():
  1. Вывод заголовка таблицы с названиями колонок (ID, Имя, Возраст, Зарплата)
  2. Вывод разделительной линии
  3. Для каждой записи в users:
     - Форматированный вывод всех полей записи в табличном виде
  4. Возврат к главному меню


4.4. ДОБАВЛЕНИЕ ЗАПИСИ

Алгоритм HandleAddUser():
  1. Цикл добавления записей (до выхода пользователя):
     1.1. Ввод имени:
          - Проверка на пустую строку
          - Проверка длины (максимум 30 символов)
          - Возможность выхода по символу '-'
     
     1.2. Ввод возраста:
          - Валидация ввода (число)
          - Проверка диапазона (0-100)
          - Возможность выхода по значению 0
     
     1.3. Ввод зарплаты:
          - Валидация ввода (число)
          - Проверка на неотрицательность
          - Возможность выхода по значению -1
     
     1.4. Создание нового объекта User с введенными данными
     1.5. Вызов AddToTable():
          - Определение ID новой записи:
            * Если контейнер пуст: ID = 0
            * Иначе: ID = последний ID + 1
          - Добавление записи в конец контейнера users
     
     1.6. Вывод добавленной записи
     1.7. Запрос о продолжении добавления
     1.8. Если пользователь не хочет продолжать - выход из цикла


4.5. УДАЛЕНИЕ ЗАПИСИ ПО ID

Алгоритм HandleDeleteUserById():
  1. Цикл запроса ID (до успешного удаления или выхода):
     1.1. Ввод ID с валидацией:
          - Проверка корректности ввода (целое число)
          - Возможность выхода по значению -1
     
     1.2. Вызов DeleteUserById():
          - Линейный поиск записи с указанным ID в контейнере users
          - Если запись найдена:
            * Удаление записи из контейнера методом erase()
            * Возврат true
          - Если не найдена:
            * Возврат false
     
     1.3. Если удаление успешно:
          - Вывод сообщения об успехе
          - Выход из цикла
     1.4. Иначе:
          - Вывод сообщения о том, что запись не найдена
          - Продолжение цикла запроса ID


4.6. ПОИСК ПО ПОЛЮ

Алгоритм HandleFindByField():
  1. Отображение подменю выбора поля для поиска:
     - Поиск по ID
     - Поиск по имени
     - Поиск по возрасту
     - Поиск по зарплате
     - Возврат в главное меню (0)
  
  2. Ввод выбора поля с валидацией
  
  3. В зависимости от выбора:
     
     3.1. Поиск по ID (HandleFindByIDField):
          - Ввод ID с валидацией
          - Вызов FindAndPrintUsersById():
            * Линейный поиск записи с указанным ID
            * Вывод найденной записи или сообщения об отсутствии
     
     3.2. Поиск по имени (HandleFindByNameField):
          - Ввод имени с валидацией (не пустое, <= 30 символов)
          - Вызов FindAndPrintUsersByName():
            * Линейный поиск всех записей с совпадающим именем
            * Вывод всех найденных записей или сообщения об отсутствии
     
     3.3. Поиск по возрасту (HandleFindByAgeField):
          - Ввод возраста с валидацией (0-100)
          - Вызов FindAndPrintUsersByAge():
            * Линейный поиск всех записей с совпадающим возрастом
            * Вывод всех найденных записей или сообщения об отсутствии
     
     3.4. Поиск по зарплате (HandleFindBySalaryField):
          - Ввод зарплаты с валидацией (неотрицательное число)
          - Вызов FindAndPrintUsersBySalary():
            * Линейный поиск всех записей с совпадающей зарплатой
            * Вывод всех найденных записей или сообщения об отсутствии
  
  4. Возврат в подменю поиска


4.7. СОРТИРОВКА ПО ВЫБРАННОМУ ПОЛЮ

Алгоритм SortTableBy() - пузырьковая сортировка:
  1. Проверка размера массива users:
     - Если размер <= 1: завершение функции (массив уже отсортирован)
     - Иначе: переход к шагу 2
  
  2. Пузырьковая сортировка (два вложенных цикла):
     2.1. Внешний цикл: for (int i = 0; i < n - 1; i++)
          - Выполняется n-1 итераций, где n - размер массива
          - На каждой итерации "всплывает" один максимальный элемент в конец
     
     2.2. Внутренний цикл: for (int j = 0; j < n - i - 1; j++)
          - Сравнивает пары соседних элементов users[j] и users[j + 1]
          - Количество сравнений уменьшается на каждой итерации внешнего цикла
     
     2.3. Выбор поля для сравнения через switch-case по параметру sort_by:
          - SortBy::Name: сравнение users[j].name > users[j + 1].name (лексикографическое)
          - SortBy::Age: сравнение users[j].age > users[j + 1].age
          - SortBy::Salary: сравнение users[j].salary > users[j + 1].salary
          - SortBy::Id: сравнение users[j].id > users[j + 1].id
     
     2.4. Если условие сравнения выполняется (элементы в неправильном порядке):
          - Сохранение users[j] во временную переменную temp
          - Присвоение users[j] = users[j + 1]
          - Присвоение users[j + 1] = temp (обмен элементов местами)
  
  3. Результат: массив users отсортирован по возрастанию выбранного поля
  4. Сложность алгоритма: O(n²), где n - количество элементов в массиве


5. ВСПОМОГАТЕЛЬНЫЕ АЛГОРИТМЫ

5.1. ПАРСИНГ СТРОКИ ИЗ ФАЙЛА (ParseFileLine)

  1. Поиск первой запятой в строке
  2. Извлечение имени (от начала до первой запятой):
     - Обрезка пробелов (Trim)
     - Валидация длины (1-30 символов)
  3. Поиск второй запятой
  4. Извлечение возраста (между первой и второй запятой):
     - Обрезка пробелов
     - Проверка на число (StringIsNumber)
     - Преобразование в число (stoi)
     - Валидация диапазона (0-100)
  5. Извлечение зарплаты (от второй запятой до конца):
     - Обрезка пробелов
     - Проверка на число
     - Преобразование в число
     - Валидация (неотрицательное)
  6. Заполнение структуры User полученными данными
  7. Возврат true при успешном парсинге, false при ошибке


5.2. ВАЛИДАЦИЯ ВВОДА

Для всех операций ввода:
  1. Проверка состояния потока ввода (cin.fail())
  2. При ошибке:
     - Очистка флагов ошибок (cin.clear())
     - Очистка буфера ввода (cin.ignore())
     - Вывод сообщения об ошибке
     - Повторный запрос ввода
  3. Проверка соответствия введенных данных ожидаемому формату и ограничениям
  4. Повторный запрос при несоответствии


6. ОСОБЕННОСТИ РЕАЛИЗАЦИИ

- Использование линейного поиска для всех операций поиска (O(n))
- Последовательное присвоение ID при добавлении записей (инкремент от последнего)
- Хранение данных только в оперативной памяти (vector)
- Формат файла: текстовый, каждая строка - одна запись в формате CSV
- Обработка ошибок ввода-вывода на всех этапах
- Валидация всех вводимых данных перед добавлением/поиском
